#!/bin/bash

# Butter - Simplified note and todo management (no rofi)
# Terminal-only version with clean sub-prompts

# Self-contained script - no dependencies on installation directory

# Note taking function with clipboard support
note() {
    # Source config if available
    [ -f ~/.config/butternotes/butter.conf ] && source ~/.config/butternotes/butter.conf

    local note_file="${NOTES_FILE:-$HOME/Documents/ButterNotes/notes.md}"

    # Migrate from old location if it exists
    if [ -f "$HOME/.notes" ] && [ ! -f "$note_file" ]; then
        mkdir -p "$(dirname "$note_file")"
        echo "# Notes" > "$note_file"
        echo "" >> "$note_file"
        cat "$HOME/.notes" >> "$note_file"
        echo "üì¶ Migrated notes from ~/.notes to $note_file"
    fi

    # Create directory and file if they don't exist
    mkdir -p "$(dirname "$note_file")"
    [ ! -f "$note_file" ] && echo "# Notes" > "$note_file"

    if [ "$#" -eq 0 ]; then
        if [ -f "$note_file" ]; then
            echo "üìù Notes:"
            local count=1
            local in_note=false
            local note_content=""

            while IFS= read -r line; do
                # Check if line starts with timestamp pattern
                if [[ "$line" =~ ^\[([0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2})\] ]]; then
                    # If we were already in a note, print it
                    if [ "$in_note" = true ] && [ -n "$note_content" ]; then
                        echo -e "  \033[1;33m[$count]\033[0m $note_content"
                        ((count++))
                    fi
                    # Start new note
                    note_content="$line"
                    in_note=true
                elif [ "$in_note" = true ]; then
                    # Continue current note (multi-line)
                    if [ -n "$line" ]; then
                        note_content="$note_content\n    $line"
                    fi
                fi
            done < "$note_file"

            # Print last note if exists
            if [ "$in_note" = true ] && [ -n "$note_content" ]; then
                echo -e "  \033[1;33m[$count]\033[0m $note_content"
            fi
        else
            echo "üìù No notes yet. Use 'note <text>' to add your first note."
        fi
    elif [ "$1" = "clip" ] || [ "$1" = "clipboard" ]; then
        # Get clipboard content
        local clip_content=""
        if command -v xclip >/dev/null 2>&1; then
            clip_content=$(xclip -selection clipboard -o 2>/dev/null)
        elif command -v xsel >/dev/null 2>&1; then
            clip_content=$(xsel --clipboard --output 2>/dev/null)
        elif command -v wl-paste >/dev/null 2>&1; then
            # Force text output for Wayland
            clip_content=$(wl-paste -t text 2>/dev/null || wl-paste -n 2>/dev/null)
        elif command -v pbpaste >/dev/null 2>&1; then
            clip_content=$(pbpaste 2>/dev/null)
        else
            echo "‚ùå No clipboard tool found. Install xclip, xsel, or wl-clipboard"
            return 1
        fi

        # Check if content looks like text (not binary)
        if [ -n "$clip_content" ]; then
            if [[ "$clip_content" =~ [^[:print:][:space:]] ]]; then
                echo "‚ö†Ô∏è  Clipboard contains non-text data (image, file, etc.)"
                return 1
            fi

            # Check size limit (100KB)
            if [[ ${#clip_content} -gt 102400 ]]; then
                echo "‚ö†Ô∏è  Clipboard content too large (${#clip_content} chars)"
                return 1
            fi

            # Handle multi-line content by indenting continuation lines
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] [CLIPBOARD]" >> "$note_file"
            echo "$clip_content" | sed 's/^/  /' >> "$note_file"
            echo "" >> "$note_file"
            echo "üìã Clipboard content added to notes"
        else
            echo "‚ö†Ô∏è  Clipboard is empty"
        fi
    elif [ "$1" = "rm" ]; then
        if [ -z "$2" ]; then
            echo "Usage: note rm <note_numbers...>"
            echo "Examples: note rm 3  |  note rm 1 3 5  |  note rm 2-5"
            return 1
        fi

        if [ -f "$note_file" ]; then
            local notes_to_remove=()
            shift # Remove 'remove' from arguments

            # Parse all note numbers/ranges
            for arg in "$@"; do
                if [[ "$arg" =~ ^([0-9]+)-([0-9]+)$ ]]; then
                    # Handle range like "2-5"
                    local start="${BASH_REMATCH[1]}"
                    local end="${BASH_REMATCH[2]}"
                    for ((i=start; i<=end; i++)); do
                        notes_to_remove+=("$i")
                    done
                elif [[ "$arg" =~ ^[0-9]+$ ]]; then
                    # Single number
                    notes_to_remove+=("$arg")
                else
                    echo "‚ö†Ô∏è  Invalid note number or range: $arg"
                    return 1
                fi
            done

            # Sort and remove duplicates, then reverse order
            local sorted_notes=($(printf '%s\n' "${notes_to_remove[@]}" | sort -rnu))

            # Create temp file for the new content
            local temp_file="$note_file.tmp"
            > "$temp_file"

            # Parse notes and skip the ones to be removed
            local count=1
            local in_note=false
            local note_content=""
            local note_start_line=""
            local should_skip=false

            while IFS= read -r line; do
                # Check if line starts with timestamp pattern
                if [[ "$line" =~ ^\[([0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2})\] ]]; then
                    # If we were in a note, decide whether to save it
                    if [ "$in_note" = true ] && [ -n "$note_content" ]; then
                        if [ "$should_skip" = false ]; then
                            echo -e "$note_content" >> "$temp_file"
                        else
                            echo "‚ùå Removed note #$count: ${note_start_line:0:50}..."
                        fi
                        ((count++))
                    fi

                    # Check if this note should be removed
                    should_skip=false
                    for num in "${sorted_notes[@]}"; do
                        if [ "$count" -eq "$num" ]; then
                            should_skip=true
                            break
                        fi
                    done

                    # Start new note
                    note_content="$line"
                    note_start_line="$line"
                    in_note=true
                elif [ "$in_note" = true ]; then
                    # Continue current note
                    note_content="$note_content\n$line"
                fi
            done < "$note_file"

            # Handle last note
            if [ "$in_note" = true ] && [ -n "$note_content" ]; then
                if [ "$should_skip" = false ]; then
                    echo -e "$note_content" >> "$temp_file"
                else
                    echo "‚ùå Removed note #$count: ${note_start_line:0:50}..."
                fi
            fi

            # Replace original file with temp file
            mv "$temp_file" "$note_file"
        else
            echo "üìù No notes file exists yet."
        fi
    elif [ "$1" = "clear" ]; then
        if [ -f "$note_file" ]; then
            echo -n "‚ö†Ô∏è  Delete all notes? (y/N): "
            read -r confirm
            if [[ "$confirm" =~ ^[yY]$ ]]; then
                > "$note_file"
                echo "üóëÔ∏è  All notes cleared"
            else
                echo "Cancelled"
            fi
        else
            echo "üìù No notes to clear"
        fi
    elif [ "$1" = "edit" ]; then
        ${BUTTER_EDITOR:-${EDITOR:-nano}} "$note_file"
    elif [ "$1" = "help" ]; then
        echo "Usage:"
        echo "  note              - List all notes numbered by entry"
        echo "  note <text>       - Add a new note with timestamp"
        echo "  note clip         - Add clipboard content as note"
        echo "  note rm <n>       - Remove note number n"
        echo "  note rm 1-5       - Remove notes 1 through 5"
        echo "  note rm 1 3 5     - Remove multiple specific notes"
        echo "  note clear        - Delete all notes (with confirmation)"
        echo "  note edit         - Open notes file in editor"
        echo "  note help         - Show this help"
    else
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >> "$note_file"
        echo "‚úÖ Note added to $note_file"
    fi
}

# Task/Todo management function
todo() {
    # Source config if available
    [ -f ~/.config/butternotes/butter.conf ] && source ~/.config/butternotes/butter.conf

    local todo_file="${TODOS_FILE:-$HOME/Documents/ButterNotes/todos.md}"

    # Migrate from old location if it exists
    if [ -f "$HOME/.tasks" ] && [ ! -f "$todo_file" ]; then
        mkdir -p "$(dirname "$todo_file")"
        echo "# Todos" > "$todo_file"
        echo "" >> "$todo_file"
        cat "$HOME/.tasks" >> "$todo_file"
        echo "üì¶ Migrated todos from ~/.tasks to $todo_file"
    fi

    # Create directory and file if they don't exist
    mkdir -p "$(dirname "$todo_file")"
    [ ! -f "$todo_file" ] && echo "# Todos" > "$todo_file"

    case "$1" in
        ""|list)
            # List all tasks with consistent numbering
            if [ -s "$todo_file" ]; then
                echo "üìã Tasks:"
                local count=1
                while IFS= read -r line; do
                    if [[ "$line" == "[ ]"* ]]; then
                        echo -e "  \033[1;33m[$count]\033[0m ‚òê ${line:4}"
                        ((count++))
                    elif [[ "$line" == "[x]"* ]]; then
                        # Keep numbering for completed tasks
                        echo -e "  \033[90m[$count]\033[0m \033[90m‚òë ~~${line:4}~~\033[0m"
                        ((count++))
                    fi
                done < "$todo_file"

                # Count summary
                local active=$(grep -c "^\[ \]" "$todo_file" 2>/dev/null || echo 0)
                local done=$(grep -c "^\[x\]" "$todo_file" 2>/dev/null || echo 0)
                echo -e "\n  \033[90m$active active, $done completed\033[0m"
            else
                echo "No tasks yet. Use 'todo <task>' to add your first task."
            fi
            ;;

        done|complete|finish)
            # Mark task as complete (now counts all tasks, not just active)
            if [ -z "$2" ]; then
                echo "Usage: todo done <number>"
                return 1
            fi

            local task_num="$2"
            # Validate that task_num is a number
            if ! [[ "$task_num" =~ ^[0-9]+$ ]]; then
                echo "‚ö†Ô∏è  Task number must be a number, not '$task_num'"
                echo "Usage: todo done <number>"
                echo "Did you mean: todo \"$1 $task_num\"?"
                return 1
            fi

            local count=1
            local temp_file="$todo_file.tmp"
            local found=false

            while IFS= read -r line; do
                if [[ "$line" == "[ ]"* ]] || [[ "$line" == "[x]"* ]]; then
                    if [ "$count" -eq "$task_num" ]; then
                        if [[ "$line" == "[ ]"* ]]; then
                            # Mark as complete
                            echo "[x] ${line:4} ($(date '+%Y-%m-%d'))" >> "$temp_file"
                            echo "‚úì Completed: ${line:4}"
                            found=true
                        elif [[ "$line" == "[x]"* ]]; then
                            # Already completed - toggle back to incomplete
                            local task_text="${line:4}"
                            # Remove the date suffix if present
                            task_text="${task_text% (*}"
                            echo "[ ] $task_text" >> "$temp_file"
                            echo "‚Ü©Ô∏è Uncompleted: $task_text"
                            found=true
                        fi
                    else
                        echo "$line" >> "$temp_file"
                    fi
                    ((count++))
                else
                    echo "$line" >> "$temp_file"
                fi
            done < "$todo_file"

            if [ "$found" = true ]; then
                mv "$temp_file" "$todo_file"
            else
                rm -f "$temp_file"
                echo "Task #$task_num not found"
                return 1
            fi
            ;;

        clear|clean)
            # Remove completed (struck-through) tasks
            local temp_file="$todo_file.tmp"
            grep "^\[ \]" "$todo_file" > "$temp_file" 2>/dev/null || true
            local removed_count=$(grep -c "^\[x\]" "$todo_file" 2>/dev/null || echo 0)
            mv "$temp_file" "$todo_file"
            echo "üóëÔ∏è Cleared $removed_count completed tasks"
            ;;

        rm)
            # Remove a specific task
            if [ -z "$2" ]; then
                echo "Usage: todo rm <number>"
                return 1
            fi

            local task_num="$2"
            # Validate that task_num is a number
            if ! [[ "$task_num" =~ ^[0-9]+$ ]]; then
                echo "‚ö†Ô∏è  Task number must be a number, not '$task_num'"
                echo "Usage: todo rm <number>"
                return 1
            fi

            local count=1
            local temp_file="$todo_file.tmp"
            local found=false

            while IFS= read -r line; do
                if [[ "$line" == "[ ]"* ]] || [[ "$line" == "[x]"* ]]; then
                    if [ "$count" -eq "$task_num" ]; then
                        if [[ "$line" == "[ ]"* ]]; then
                            echo "‚úó Removed: ${line:4}"
                        else
                            echo "‚úó Removed completed: ${line:4}"
                        fi
                        found=true
                    else
                        echo "$line" >> "$temp_file"
                    fi
                    ((count++))
                else
                    echo "$line" >> "$temp_file"
                fi
            done < "$todo_file"

            if [ "$found" = true ]; then
                mv "$temp_file" "$todo_file"
            else
                rm -f "$temp_file"
                echo "Task #$task_num not found"
                return 1
            fi
            ;;

        help)
            echo "Usage:"
            echo "  todo              - List active tasks (completed shown struck-through)"
            echo "  todo <task>       - Add a new task"
            echo "  todo done <n>     - Mark task #n as complete (strikethrough)"
            echo "  todo rm <n>       - Delete task #n completely"
            echo "  todo clear        - Remove struck-through completed tasks"
            echo "  todo help         - Show this help"
            ;;

        *)
            # Add new task
            echo "[ ] $*" >> "$todo_file"
            echo "‚úì Added: $*"
            ;;
    esac
}

# FZF integration functions
select_project() {
    # Source config to get BUTTER_NOTES_DIR
    [ -f ~/.config/butternotes/butter.conf ] && source ~/.config/butternotes/butter.conf
    
    local projects_dir="${BUTTER_NOTES_DIR:-$HOME/Documents/ButterNotes}/projects"
    
    # Create projects directory if it doesn't exist
    mkdir -p "$projects_dir"
    
    if command -v fzf >/dev/null 2>&1; then
        # Combine projects with management actions
        {
            echo "üìù New project"
            echo "üóëÔ∏è  Delete project"
            echo "üö™ Exit"
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            find "$projects_dir" -name "*.md" -exec basename {} .md \; 2>/dev/null | sort
        } | fzf --prompt="Project Manager: " \
                --bind='ctrl-n:execute(echo "üìù New project")+accept' \
                --bind='ctrl-d:execute(echo "üóëÔ∏è  Delete project")+accept' \
                --bind='tab:toggle-preview' \
                --header='Enter: Edit ‚Ä¢ Ctrl-N: New ‚Ä¢ Ctrl-D: Delete ‚Ä¢ Tab: Toggle Preview' \
                --preview="
                    if [[ {} == 'üìù New project' ]]; then
                        echo 'Create a new project'
                    elif [[ {} == 'üóëÔ∏è  Delete project' ]]; then
                        echo 'Delete an existing project'
                    elif [[ {} == 'üö™ Exit' ]]; then
                        echo 'Exit project manager'
                    elif [[ {} == '‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ' ]]; then
                        echo 'Select a project below to edit'
                    else
                        cat '$projects_dir/{}.md' 2>/dev/null || echo 'Empty project'
                    fi
                " \
                --preview-window=right:50% \
                --height=40%
    else
        # Fallback to simple numbered list
        echo "Project Manager:" >&2
        echo "  1) üìù New project" >&2
        echo "  2) üóëÔ∏è  Delete project" >&2
        echo "  3) üö™ Exit" >&2
        echo "  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" >&2
        
        local i=4
        local projects=()
        projects[1]="üìù New project"
        projects[2]="üóëÔ∏è  Delete project"
        projects[3]="üö™ Exit"
        
        while IFS= read -r -d '' project_file; do
            local project_name=$(basename "$project_file" .md)
            echo "  $i) $project_name" >&2
            projects[$i]="$project_name"
            ((i++))
        done < <(find "$projects_dir" -name "*.md" -print0 2>/dev/null)
        
        read -p "Choose option [1-$((i-1))]: " choice >&2
        if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -lt "$i" ]; then
            echo "${projects[$choice]}"
        else
            echo "" # Invalid choice
        fi
    fi
}

# Template selection and application functions
select_template() {
    echo "Choose project template:" >&2
    echo "  1) Blank (default)" >&2
    echo "  2) Daily log" >&2
    echo "  3) Simple list" >&2
    echo >&2
    read -p "Template [1-3]: " template_choice </dev/tty

    case "${template_choice:-1}" in
        1|blank|"") echo "blank" ;;
        2|daily|log) echo "daily-log" ;;
        3|list|simple) echo "simple-list" ;;
        *) echo "blank" ;;
    esac
}

apply_template() {
    local project_file="$1"
    local project_name="$2"
    local template="$3"

    # Source config to get template directory
    [ -f ~/.config/butternotes/butter.conf ] && source ~/.config/butternotes/butter.conf
    local template_file="$HOME/.config/butternotes/templates/${template}.md"

    if [ -f "$template_file" ]; then
        # Apply template with substitutions
        sed "s/PROJECT_NAME/$project_name/g; s/DATE_PLACEHOLDER/$(date '+%Y-%m-%d')/g" "$template_file" > "$project_file"
    else
        # Fallback to simple blank template
        echo "# $project_name" > "$project_file"
    fi
}

create_new_project() {
    echo
    template=$(select_template)
    echo
    read -p "New project name: " new_name </dev/tty
    if [ -n "$new_name" ]; then
        # Source config to get BUTTER_NOTES_DIR
        [ -f ~/.config/butternotes/butter.conf ] && source ~/.config/butternotes/butter.conf
        local projects_dir="${BUTTER_NOTES_DIR:-$HOME/Documents/ButterNotes}/projects"
        local project_file="$projects_dir/${new_name}.md"

        # Create projects directory if it doesn't exist
        mkdir -p "$projects_dir"

        # Apply template and open for editing
        apply_template "$project_file" "$new_name" "$template"
        echo "‚úÖ Project '$new_name' created with $template template"
        ${BUTTER_EDITOR:-${EDITOR:-nano}} "$project_file"
    fi
}

# Show help
show_help() {
    cat << EOF
üßà Butter - Smart note and todo management

Usage: butter [COMMAND] [ARGS...]

Commands:
  add TEXT           Add a note with TEXT
  clip              Save clipboard content as note
  notes edit         Edit notes file (shortcut: n edit)
  notes rm           Clear all notes (shortcut: n rm)
  todo TEXT         Add a todo item
  todos             List all todos
  project NAME      View project notes (shortcut: p NAME)
  project NAME edit Edit project file (shortcut: p NAME edit)  
  project           Project manager - select/create/delete (shortcut: p)
  projects          List all projects
  list              List all notes
  edit              Open notes file in editor (legacy)
  help              Show this help
  
Quick Usage:
  butter "Quick note"           # Add note
  butter todo "Fix bug"         # Add todo
  butter project python        # View python project notes
  butter project               # Project manager (fzf)
  butter clip                   # Save clipboard
  butter                        # Interactive mode

Examples:
  # Add to your ~/.bashrc or ~/.config/bash/aliases
  alias b='butter'
  alias bc='butter clip'
  alias bt='butter todo'

Note: When called without arguments, butter enters interactive mode.
EOF
}

# Note sub-prompt
note_prompt() {
    # Disable alias expansion in this subshell
    set +o posix 2>/dev/null
    
    echo "üìù Notes Mode"
    echo "Commands: a(dd), l(ist), e(dit), rm, c(lip), s(earch), h(elp), .. (back)"
    echo
    
    while true; do
        read -r -p "üßà butter/notes ‚ùØ " input
        
        # Split input into command and args
        cmd="${input%% *}"
        args="${input#* }"
        [ "$cmd" = "$args" ] && args=""
        
        case "$cmd" in
            a|add)
                if [ -n "$args" ]; then
                    note "$args"
                else
                    read -r -p "Note text: " text
                    [ -n "$text" ] && note "$text"
                fi
                ;;
            l|ls|list)
                note
                ;;
            e|edit)
                note edit
                ;;
            rm|r|del)
                if [ -n "$args" ]; then
                    note rm $args
                else
                    echo "Usage: rm <note_numbers>"
                    echo "Examples: rm 3  |  rm 1-5  |  rm 1 3 5"
                fi
                ;;
            clear)
                note clear
                ;;
            c|clip)
                note clip
                ;;
            s|search|/)
                if [ -n "$args" ]; then
                    grep -i "$args" "${NOTES_FILE:-$HOME/Documents/ButterNotes/notes.md}" 2>/dev/null || echo "No matches found"
                else
                    read -r -p "Search for: " term
                    [ -n "$term" ] && grep -i "$term" "${NOTES_FILE:-$HOME/Documents/ButterNotes/notes.md}" 2>/dev/null || echo "No matches found"
                fi
                ;;
            h|help|?)
                echo "Notes Commands:"
                echo "  a       - Add a new note (or just type text)"
                echo "  l       - List all notes"
                echo "  e       - Edit notes file"
                echo "  rm <n>  - Remove note(s)"
                echo "  c       - Save clipboard"
                echo "  s or /  - Search notes"
                echo "  clear   - Delete all notes"
                echo "  ..      - Back to main menu (or type 'exit')"
                ;;
            ..|back|exit|quit)
                break
                ;;
            "")
                continue
                ;;
            *)
                # If no command matched, treat it as adding a note
                note "$cmd $args"
                ;;
        esac
        echo
    done
}

# Todo sub-prompt
todo_prompt() {
    # Disable alias expansion in this subshell
    set +o posix 2>/dev/null
    
    echo "‚úÖ Todo Mode"
    echo "Commands: a(dd), l(ist), d(one) <n>, rm <n>, h(elp), .. (back)"
    echo
    
    while true; do
        read -r -p "üßà butter/todos ‚ùØ " input
        
        # Split input into command and args
        cmd="${input%% *}"
        args="${input#* }"
        [ "$cmd" = "$args" ] && args=""
        
        case "$cmd" in
            a|add)
                if [ -n "$args" ]; then
                    todo add "$args"
                else
                    read -r -p "Todo text: " text
                    [ -n "$text" ] && todo add "$text"
                fi
                ;;
            l|ls|list)
                todo
                ;;
            d|done|toggle)
                if [ -n "$args" ]; then
                    todo done $args
                else
                    echo "Usage: d <todo_number>"
                fi
                ;;
            rm|r|del)
                if [ -n "$args" ]; then
                    todo rm $args
                else
                    echo "Usage: rm <todo_numbers>"
                fi
                ;;
            clear)
                todo clear
                ;;
            h|help|?)
                echo "Todo Commands:"
                echo "  a       - Add a new todo (or just type text)"
                echo "  l       - List all todos"
                echo "  d <n>   - Toggle todo done/undone"
                echo "  rm <n>  - Remove todo(s)"
                echo "  clear   - Delete all todos"
                echo "  ..      - Back to main menu (or type 'exit')"
                ;;
            ..|back|exit|quit)
                break
                ;;
            "")
                continue
                ;;
            *)
                # If no command matched, treat it as adding a todo
                todo add "$cmd $args"
                ;;
        esac
        echo
    done
}

# Notes command handler
notes_command() {
    local command="$1"
    shift
    
    # Source config to get BUTTER_NOTES_DIR
    [ -f ~/.config/butternotes/butter.conf ] && source ~/.config/butternotes/butter.conf
    
    local notes_file="${NOTES_FILE:-$HOME/Documents/ButterNotes/notes.md}"
    
    case "$command" in
        edit|e)
            ${BUTTER_EDITOR:-${EDITOR:-nano}} "$notes_file"
            ;;
        rm|remove|delete)
            if [ -f "$notes_file" ]; then
                echo -n "‚ö†Ô∏è  Delete all notes? (y/N): "
                read -r confirm
                if [[ "$confirm" =~ ^[yY]$ ]]; then
                    > "$notes_file"
                    echo "üóëÔ∏è  All notes cleared"
                else
                    echo "Cancelled"
                fi
            else
                echo "üìù No notes file exists yet."
            fi
            ;;
        list|l|ls|"")
            note
            ;;
        *)
            # Treat as note text to add
            note "$command $*"
            ;;
    esac
}

# Project note functions
project_note() {
    local project_name="$1"
    shift
    local command_or_text="$1"
    
    # Source config to get BUTTER_NOTES_DIR
    [ -f ~/.config/butternotes/butter.conf ] && source ~/.config/butternotes/butter.conf
    
    local projects_dir="${BUTTER_NOTES_DIR:-$HOME/Documents/ButterNotes}/projects"
    local project_file="$projects_dir/${project_name}.md"
    
    # Create projects directory if it doesn't exist
    mkdir -p "$projects_dir"
    
    # Check for edit or rm commands
    if [ "$command_or_text" = "edit" ]; then
        if [ -f "$project_file" ]; then
            ${BUTTER_EDITOR:-${EDITOR:-nano}} "$project_file"
        else
            echo "üìÅ Project '$project_name' doesn't exist yet."
            echo "Create it with: butter project $project_name \"your note\""
        fi
        return
    elif [ "$command_or_text" = "rm" ] || [ "$command_or_text" = "delete" ]; then
        if [ -f "$project_file" ]; then
            echo -n "‚ö†Ô∏è  Delete project '$project_name' and all its notes? (y/N): "
            read -r confirm
            if [[ "$confirm" =~ ^[yY]$ ]]; then
                rm "$project_file"
                echo "üóëÔ∏è  Project '$project_name' deleted"
            else
                echo "Cancelled"
            fi
        else
            echo "üìÅ Project '$project_name' doesn't exist."
        fi
        return
    fi
    
    local text="$command_or_text"
    shift
    [ -n "$*" ] && text="$text $*"
    
    if [ -z "$text" ]; then
        # No text provided - list notes for this project
        if [ -f "$project_file" ]; then
            echo "üìÅ Project: $project_name"
            local count=1
            local in_note=false
            local note_content=""
            
            while IFS= read -r line; do
                # Check if line starts with timestamp pattern
                if [[ "$line" =~ ^\[([0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2})\] ]]; then
                    # If we were already in a note, print it
                    if [ "$in_note" = true ] && [ -n "$note_content" ]; then
                        echo -e "  \033[1;33m[$count]\033[0m $note_content"
                        ((count++))
                    fi
                    # Start new note
                    note_content="$line"
                    in_note=true
                elif [ "$in_note" = true ]; then
                    # Continue current note (multi-line)
                    if [ -n "$line" ]; then
                        note_content="$note_content\n    $line"
                    fi
                fi
            done < "$project_file"
            
            # Print last note if exists
            if [ "$in_note" = true ] && [ -n "$note_content" ]; then
                echo -e "  \033[1;33m[$count]\033[0m $note_content"
            fi
        else
            echo "üìÅ Project '$project_name' has no notes yet."
            echo "Add a note with: butter project $project_name \"your note\""
        fi
    else
        # Add text to project
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] $text" >> "$project_file"
        echo "‚úÖ Note added to project '$project_name'"
    fi
}

list_projects() {
    # Source config to get BUTTER_NOTES_DIR
    [ -f ~/.config/butternotes/butter.conf ] && source ~/.config/butternotes/butter.conf
    
    local projects_dir="${BUTTER_NOTES_DIR:-$HOME/Documents/ButterNotes}/projects"
    
    if [ -d "$projects_dir" ] && [ -n "$(ls -A "$projects_dir" 2>/dev/null)" ]; then
        echo "üìÅ Projects:"
        for project_file in "$projects_dir"/*.md; do
            if [ -f "$project_file" ]; then
                local project_name=$(basename "$project_file" .md)
                local note_count=$(grep -c "^\[" "$project_file" 2>/dev/null || echo "0")
                echo "  $project_name ($note_count notes)"
            fi
        done
    else
        echo "üìÅ No projects yet."
        echo "Create one with: butter project <name> \"your note\""
    fi
}

# Project sub-prompt
projects_prompt() {
    # Disable alias expansion in this subshell
    set +o posix 2>/dev/null
    
    echo "üìÅ Projects Mode"
    echo "Commands: <project> \"text\", <project> e(dit), <project> rm, l(ist), h(elp), .. (back)"
    echo
    
    while true; do
        read -r -p "üßà butter/projects ‚ùØ " input
        
        # Split input into command and args
        cmd="${input%% *}"
        args="${input#* }"
        [ "$cmd" = "$args" ] && args=""
        
        case "$cmd" in
            list|l|ls)
                # Project manager
                selection=$(select_project)
                if [ -n "$selection" ]; then
                    case "$selection" in
                        "üìù New project")
                            create_new_project
                            ;;
                        "üóëÔ∏è  Delete project")
                            # Source config to get BUTTER_NOTES_DIR
                            [ -f ~/.config/butternotes/butter.conf ] && source ~/.config/butternotes/butter.conf
                            projects_dir="${BUTTER_NOTES_DIR:-$HOME/Documents/ButterNotes}/projects"
                            
                            if command -v fzf >/dev/null 2>&1 && [ -t 0 ] && [ -t 1 ]; then
                                del_project=$(find "$projects_dir" -name "*.md" -exec basename {} .md \; 2>/dev/null | sort | fzf --prompt="Delete project: ")
                                if [ -n "$del_project" ]; then
                                    project_note "$del_project" "rm"
                                fi
                            fi
                            ;;
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
                            # Separator, ignore
                            ;;
                        *)
                            # Regular project name - edit it
                            project_note "$selection" "edit"
                            ;;
                    esac
                fi
                ;;
            h|help|?)
                echo "Projects Commands:"
                echo "  l               - Project manager (new/edit/delete)"  
                echo "  <project>       - View notes for project"
                echo "  <project> e     - Edit project file"
                echo "  <project> rm    - Delete project"
                echo "  ..              - Back to main menu"
                ;;
            ..|back|exit|quit)
                break
                ;;
            "")
                continue
                ;;
            *)
                # Handle project commands
                if [ -n "$args" ]; then
                    # Check for single-letter shortcuts  
                    first_arg="${args%% *}"
                    
                    case "$first_arg" in
                        e|edit)
                            project_note "$cmd" edit
                            ;;
                        rm|r|delete)
                            project_note "$cmd" rm
                            ;;
                        *)
                            # Unknown argument
                            echo "Unknown command. Use: $cmd e (edit) or $cmd rm (delete)"
                            ;;
                    esac
                else
                    # No arguments - show project notes
                    project_note "$cmd"
                fi
                ;;
        esac
        echo
    done
}

# Interactive terminal mode
interactive_terminal() {
    echo "üßà Butter - Interactive Mode"
    echo
    echo "Commands:"
    echo "  n         - Enter notes mode"
    echo "  t         - Enter todos mode"
    echo "  p         - Enter projects mode"
    echo "  l         - Quick list notes"
    echo "  lt        - Quick list todos"
    echo "  c         - Clear screen"
    echo "  q         - Quit"
    echo
    
    while true; do
        read -r -p "üßà butter ‚ùØ " input
        
        # Split input into command and args
        cmd="${input%% *}"
        args="${input#* }"
        [ "$cmd" = "$args" ] && args=""
        
        case "$cmd" in
            n|note|notes)
                note_prompt
                ;;
            t|todo|todos)
                todo_prompt
                ;;
            l|list)
                note
                ;;
            lt)
                todo
                ;;
            p|project|projects)
                # Launch fzf project manager - loop until exit
                while true; do
                    selection=$(select_project)
                    if [ -z "$selection" ]; then
                        # User cancelled (Escape) - exit project mode
                        break
                    fi
                    
                    case "$selection" in
                        "üìù New project")
                            create_new_project
                            ;;
                        "üóëÔ∏è  Delete project")
                            # Source config to get BUTTER_NOTES_DIR
                            [ -f ~/.config/butternotes/butter.conf ] && source ~/.config/butternotes/butter.conf
                            projects_dir="${BUTTER_NOTES_DIR:-$HOME/Documents/ButterNotes}/projects"
                            
                            if command -v fzf >/dev/null 2>&1; then
                                del_project=$(find "$projects_dir" -name "*.md" -exec basename {} .md \; 2>/dev/null | sort | fzf --prompt="Delete project: ")
                                if [ -n "$del_project" ]; then
                                    project_note "$del_project" "rm"
                                fi
                            fi
                            ;;
                        "üö™ Exit")
                            # Exit project mode
                            break
                            ;;
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
                            # Separator, ignore - continue loop
                            ;;
                        *)
                            # Regular project name - edit it
                            project_note "$selection" "edit"
                            ;;
                    esac
                done
                ;;
            c|clear|cls)
                clear
                echo "üßà Butter - Interactive Mode"
                echo
                echo "Commands:"
                echo "  n         - Enter notes mode"
                echo "  t         - Enter todos mode"
                echo "  p         - Enter projects mode"
                echo "  l         - Quick list notes"
                echo "  lt        - Quick list todos"
                echo "  c         - Clear screen"
                echo "  q         - Quit"
                echo
                ;;
            q|quit|exit)
                break
                ;;
            help|h|?)
                echo "Commands: n (notes), t (todos), p (projects), l (list notes), lt (list todos), c (clear), q (quit)"
                ;;
            "")
                continue
                ;;
            *)
                echo "Unknown command: $cmd. Type 'help' for commands."
                ;;
        esac
        echo
    done
}

# Main execution
main() {
    # Terminal mode handling
    case "${1:-}" in
        add)
            shift
            if [ -n "$*" ]; then
                note "$*"
            else
                echo "Usage: butter add <text>"
                exit 1
            fi
            ;;
        clip|clipboard)
            note clip
            ;;
        todo)
            shift
            if [ -n "$*" ]; then
                todo add "$*"
            else
                todo
            fi
            ;;
        todos)
            todo
            ;;
        p|project|projects)
            shift
            if [ "$1" = "list" ]; then
                list_projects
            elif [ -z "$1" ]; then
                # Interactive project manager
                selection=$(select_project)
                if [ -n "$selection" ]; then
                    case "$selection" in
                        "üìù New project")
                            create_new_project
                            ;;
                        "üóëÔ∏è  Delete project")
                            # Source config to get BUTTER_NOTES_DIR
                            [ -f ~/.config/butternotes/butter.conf ] && source ~/.config/butternotes/butter.conf
                            projects_dir="${BUTTER_NOTES_DIR:-$HOME/Documents/ButterNotes}/projects"
                            
                            if command -v fzf >/dev/null 2>&1 && [ -t 0 ] && [ -t 1 ]; then
                                del_project=$(find "$projects_dir" -name "*.md" -exec basename {} .md \; 2>/dev/null | sort | fzf --prompt="Delete project: ")
                                if [ -n "$del_project" ]; then
                                    project_note "$del_project" "rm"
                                fi
                            fi
                            ;;
                        "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
                            # Separator, ignore
                            ;;
                        *)
                            # Regular project name - edit it
                            project_note "$selection" "edit"
                            ;;
                    esac
                fi
            else
                project_name="$1"
                shift
                if [ -z "$*" ]; then
                    # View project contents
                    project_note "$project_name"
                else
                    # Handle edit/rm commands
                    project_note "$project_name" "$*"
                fi
            fi
            ;;
        help|--help|-h)
            show_help
            ;;
        "")
            # No arguments - interactive mode
            if [ -t 0 ] && [ -t 1 ]; then
                interactive_terminal
            else
                show_help
            fi
            ;;
        *)
            # Default: treat as a note
            note "$*"
            ;;
    esac
}

# Run main function
main "$@"